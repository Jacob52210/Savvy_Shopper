{"ast":null,"code":"import { factory } from '../../utils/factory';\nimport { deepMap } from '../../utils/collection';\nimport { nearlyEqual } from '../../utils/number';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual';\nimport { ceilNumber } from '../../plain/number';\nvar name = 'ceil';\nvar dependencies = ['typed', 'config', 'round'];\nexport var createCeil = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      round = _ref.round;\n  /**\n   * Round a value towards plus infinity\n   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.ceil(x)\n   *\n   * Examples:\n   *\n   *    math.ceil(3.2)               // returns number 4\n   *    math.ceil(3.8)               // returns number 4\n   *    math.ceil(-4.2)              // returns number -4\n   *    math.ceil(-4.7)              // returns number -4\n   *\n   *    const c = math.complex(3.2, -2.7)\n   *    math.ceil(c)                 // returns Complex 4 - 2i\n   *\n   *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]\n   *\n   * See also:\n   *\n   *    floor, fix, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n\n  return typed('ceil', {\n    number: function number(x) {\n      if (nearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return ceilNumber(x);\n      }\n    },\n    Complex: function Complex(x) {\n      return x.ceil();\n    },\n    BigNumber: function BigNumber(x) {\n      if (bigNearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return x.ceil();\n      }\n    },\n    Fraction: function Fraction(x) {\n      return x.ceil();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since ceil(0) = 0\n      return deepMap(x, this, true);\n    }\n  });\n});","map":{"version":3,"sources":["C:/Websites/Wagner Projects/Savvy_Shopper/savvy-shopper/node_modules/mathjs/es/function/arithmetic/ceil.js"],"names":["factory","deepMap","nearlyEqual","bigNearlyEqual","ceilNumber","name","dependencies","createCeil","_ref","typed","config","round","number","x","epsilon","Complex","ceil","BigNumber","Fraction","ArrayMatrix"],"mappings":"AAAA,SAASA,OAAT,QAAwB,qBAAxB;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,WAAT,QAA4B,oBAA5B;AACA,SAASA,WAAW,IAAIC,cAAxB,QAA8C,mCAA9C;AACA,SAASC,UAAT,QAA2B,oBAA3B;AACA,IAAIC,IAAI,GAAG,MAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,CAAnB;AACA,OAAO,IAAIC,UAAU,GAAG,eAAeP,OAAO,CAACK,IAAD,EAAOC,YAAP,EAAqB,UAAUE,IAAV,EAAgB;AACjF,MAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,MACIC,MAAM,GAAGF,IAAI,CAACE,MADlB;AAAA,MAEIC,KAAK,GAAGH,IAAI,CAACG,KAFjB;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAAOF,KAAK,CAAC,MAAD,EAAS;AACnBG,IAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,CAAhB,EAAmB;AACzB,UAAIX,WAAW,CAACW,CAAD,EAAIF,KAAK,CAACE,CAAD,CAAT,EAAcH,MAAM,CAACI,OAArB,CAAf,EAA8C;AAC5C,eAAOH,KAAK,CAACE,CAAD,CAAZ;AACD,OAFD,MAEO;AACL,eAAOT,UAAU,CAACS,CAAD,CAAjB;AACD;AACF,KAPkB;AAQnBE,IAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBF,CAAjB,EAAoB;AAC3B,aAAOA,CAAC,CAACG,IAAF,EAAP;AACD,KAVkB;AAWnBC,IAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBJ,CAAnB,EAAsB;AAC/B,UAAIV,cAAc,CAACU,CAAD,EAAIF,KAAK,CAACE,CAAD,CAAT,EAAcH,MAAM,CAACI,OAArB,CAAlB,EAAiD;AAC/C,eAAOH,KAAK,CAACE,CAAD,CAAZ;AACD,OAFD,MAEO;AACL,eAAOA,CAAC,CAACG,IAAF,EAAP;AACD;AACF,KAjBkB;AAkBnBE,IAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkBL,CAAlB,EAAqB;AAC7B,aAAOA,CAAC,CAACG,IAAF,EAAP;AACD,KApBkB;AAqBnB,sBAAkB,SAASG,WAAT,CAAqBN,CAArB,EAAwB;AACxC;AACA,aAAOZ,OAAO,CAACY,CAAD,EAAI,IAAJ,EAAU,IAAV,CAAd;AACD;AAxBkB,GAAT,CAAZ;AA0BD,CA3D6C,CAAvC","sourcesContent":["import { factory } from '../../utils/factory';\nimport { deepMap } from '../../utils/collection';\nimport { nearlyEqual } from '../../utils/number';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual';\nimport { ceilNumber } from '../../plain/number';\nvar name = 'ceil';\nvar dependencies = ['typed', 'config', 'round'];\nexport var createCeil = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      round = _ref.round;\n\n  /**\n   * Round a value towards plus infinity\n   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.ceil(x)\n   *\n   * Examples:\n   *\n   *    math.ceil(3.2)               // returns number 4\n   *    math.ceil(3.8)               // returns number 4\n   *    math.ceil(-4.2)              // returns number -4\n   *    math.ceil(-4.7)              // returns number -4\n   *\n   *    const c = math.complex(3.2, -2.7)\n   *    math.ceil(c)                 // returns Complex 4 - 2i\n   *\n   *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]\n   *\n   * See also:\n   *\n   *    floor, fix, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n  return typed('ceil', {\n    number: function number(x) {\n      if (nearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return ceilNumber(x);\n      }\n    },\n    Complex: function Complex(x) {\n      return x.ceil();\n    },\n    BigNumber: function BigNumber(x) {\n      if (bigNearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return x.ceil();\n      }\n    },\n    Fraction: function Fraction(x) {\n      return x.ceil();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since ceil(0) = 0\n      return deepMap(x, this, true);\n    }\n  });\n});"]},"metadata":{},"sourceType":"module"}